/***************************************************************************
**
** Copyright (c) 2012-2019 Jolla Ltd.
** Copyright (c) 2020 Open Mobile Platform LLC.
**
** This file is part of lipstick.
**
** This library is free software; you can redistribute it and/or
** modify it under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation
** and appearing in the file LICENSE.LGPL included in the packaging
** of this file.
**
****************************************************************************/

#include <NgfClient>
#include <QWaylandSurface>
#include <QUrl>

#include "lipstickcompositor.h"
#include "notificationmanager.h"
#include "lipsticknotification.h"
#include "notificationfeedbackplayer.h"

namespace {

enum PreviewMode {
    AllNotificationsEnabled = 0,
    ApplicationNotificationsDisabled,
    SystemNotificationsDisabled,
    AllNotificationsDisabled
};

QString DefaultFeedback = QStringLiteral("default");
QString NgfSoundEnabled = QStringLiteral("sound.enabled");
}

NotificationFeedbackPlayer::NotificationFeedbackPlayer(QObject *parent)
    : QObject(parent)
    , m_ngfClient(new Ngf::Client(this))
    , m_doNotDisturbSetting(QLatin1String("/lipstick/do_not_disturb"))
{
    connect(NotificationManager::instance(), SIGNAL(notificationRemoved(uint)),
            this, SLOT(removeNotification(uint)));

    QTimer::singleShot(0, this, SLOT(init()));
}

void NotificationFeedbackPlayer::init()
{
    m_ngfClient->connect();
}

bool NotificationFeedbackPlayer::addNotification(uint id)
{
    LipstickNotification *notification = NotificationManager::instance()->notification(id);
    bool feedbackPlayed = false;

    // feedback on progress update just directly omitted, not expecting practical use for playing feedback on every update
    if (notification != nullptr && !notification->hasProgress()) {
        // Stop feedback previously generated by this notification, if current
        QMultiHash<LipstickNotification *, uint>::iterator it = m_idToEventId.find(notification);
        while (it != m_idToEventId.end() && it.key() == notification) {
            m_ngfClient->stop(it.value());
            it = m_idToEventId.erase(it);
        }

        // Play the feedback related to the notification if any
        const QString feedback = notification->hints().value(LipstickNotification::HINT_FEEDBACK).toString();
        QStringList feedbackItems = feedback.split(QStringLiteral(","), QString::SkipEmptyParts);

        if (isEnabled(notification)) {
            QMap<QString, QVariant> properties;
            QMap<QString, QVariant> customSoundProperties;

            if (notification->body().isEmpty() && notification->summary().isEmpty()) {
                properties.insert("media.leds", false);
            }
            if (notification->hints().value(LipstickNotification::HINT_SUPPRESS_SOUND, false).toBool()) {
                properties.insert("media.audio", false);
            }
            if (!notification->hints().value(LipstickNotification::HINT_ORIGIN_PACKAGE).toString().isEmpty()) {
                // android notification, play vibra only when explicitly asked via separate hint
                properties.insert("media.vibra", false);
            }

            if (doNotDisturbMode()) {
                // no sound or vibra, but led is allowed
                properties.insert("media.vibra", false);
                properties.insert("media.audio", false);
            } else {
                QString soundFile = notification->hints().value(LipstickNotification::HINT_SOUND_FILE).toString();
                QString soundName = notification->hints().value(LipstickNotification::HINT_SOUND_NAME).toString();

                // Named sound overrides if available
                if (soundName == QLatin1String("message-new-instant")) {
                    soundFile = m_profileControl.chatToneFile();
                } else if (soundName == QLatin1String("message-new-email")) {
                    soundFile = m_profileControl.mailToneFile();
                }

                if (!soundFile.isEmpty()) {
                    if (soundFile.startsWith(QStringLiteral("file://"))) {
                        soundFile = QUrl(soundFile).toLocalFile();
                    }

                    customSoundProperties.insert(QStringLiteral("sound.filename"), soundFile);
                    // Sound is enabled explicitly if sound-file hint is set.
                    customSoundProperties.insert(NgfSoundEnabled, true);
                }
            }

            // Add generic feedback type if needed
            if (!customSoundProperties.isEmpty() && !feedbackItems.contains(DefaultFeedback)) {
                feedbackItems << DefaultFeedback;
            }

            foreach (const QString &item, feedbackItems) {
                QMap<QString, QVariant> effectiveProperties = properties;

                if (item == DefaultFeedback) {
                    for (auto key : customSoundProperties.keys()) {
                        effectiveProperties.insert(key, customSoundProperties.value(key));
                    }
                } else if (!customSoundProperties.isEmpty()) {
                    // custom sound overrides other sounds
                    effectiveProperties.insert(NgfSoundEnabled, false);
                }
                m_ngfClient->stop(item);
                m_idToEventId.insert(notification, m_ngfClient->play(item, effectiveProperties));
                feedbackPlayed = true;
            }
        }

        // vibra played if it's asked regardless of priorities
        if (!doNotDisturbMode() && isEnabled(notification)
                && notification->hints().value(LipstickNotification::HINT_VIBRA, false).toBool()) {
            m_ngfClient->stop("vibra");
            m_idToEventId.insert(notification, m_ngfClient->play("vibra", QMap<QString, QVariant>()));
            feedbackPlayed = true;
        }
    }

    return feedbackPlayed;
}

void NotificationFeedbackPlayer::removeNotification(uint id)
{
    LipstickNotification *notification = NotificationManager::instance()->notification(id);

    if (notification != nullptr) {
        // Stop the feedback related to the notification, if any
        QMultiHash<LipstickNotification *, uint>::iterator it = m_idToEventId.find(notification);
        while (it != m_idToEventId.end() && it.key() == notification) {
            m_ngfClient->stop(it.value());
            it = m_idToEventId.erase(it);
        }
    }
}

bool NotificationFeedbackPlayer::isEnabled(LipstickNotification *notification)
{
    if (notification->restored())
        return false;

    uint mode = AllNotificationsEnabled;
    QWaylandSurface *surface
            = LipstickCompositor::instance()->surfaceForId(LipstickCompositor::instance()->topmostWindowId());
    if (surface != nullptr) {
        mode = surface->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED",
                                                 uint(AllNotificationsEnabled)).toUInt();
    }

    int urgency = notification->urgency();
    int notificationIsCritical = urgency >= 2
            || notification->hints().value(LipstickNotification::HINT_DISPLAY_ON).toBool();

    return mode == AllNotificationsEnabled
            || (mode == ApplicationNotificationsDisabled && notificationIsCritical)
            || (mode == SystemNotificationsDisabled && urgency < 2);
}

bool NotificationFeedbackPlayer::doNotDisturbMode() const
{
    return m_doNotDisturbSetting.value().toBool();
}
